{"version":3,"sources":["shader-utils.js"],"names":[],"mappings":"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","file":"shader-utils-compiled.js","sourcesContent":["\ndefine( [\n\n        'fp/fp-base'\n\n    ],\n\n    function( FiercePlanet ) {\n\n\n        /**\n         * Shader utilites - wrappers around Three.js Lambert and Phong shaders.\n         */\n        FiercePlanet.ShaderUtils = {\n\n            buildingVertexShaderParams: function() {\n                var shader =\n                    `\n                        varying vec3 pos;\n                        varying float vMixin;\n                        attribute float mixin;\n                        uniform float time;\n                    `;\n                return shader;\n            },\n            buildingVertexShaderMain: function() {\n                var shader = `\n                        pos = position;\n                        vMixin = mixin;\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                    `;\n                return shader;\n            },\n\n            buildingFragmentShaderParams: function() {\n                var shader = `\n                        uniform float time;\n                        uniform vec2 location;\n                        uniform vec2 resolution;\n                        uniform vec3 dimensions;\n                        uniform float bottomWindow;\n                        uniform float topWindow;\n                        uniform float windowWidth;\n                        uniform float windowPercent;\n                        uniform float floorLevel;\n                        uniform float lineWidth;\n                        uniform int showLines;\n                        uniform int showFill;\n                        uniform int showWindows;\n                        uniform int fillRooves;\n                        uniform vec3 lineColor;\n                        uniform vec3 fillColor;\n                        uniform vec3 windowColor;\n                        varying vec3 pos;\n                        varying float vMixin;\n\n                        // Basic random generator, taken from http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n                        // and http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n                        // For something more sophisticated try github.com/ashima/webgl-noise\n                        float rand( vec2 co ) {\n                            return fract( sin( dot( co.xy ,vec2( 12.9898,78.233 )) ) * 43758.5453 );\n                        }\n                    `;\n                return shader;\n            },\n            buildingFragmentShaderMain: function() {\n                var shader = `\n                        vec3 darkGrey = vec3( 0.1,0.1,0.1 );\n                        vec4 col = vec4( darkGrey, 1. );\n                        float opacity = 1.;\n                        if ( showFill == 1 ) {\n                            col = vec4( mix( fillColor, darkGrey, rand( location ) ), opacity );\n                        }\n                        bool colorise = false;\n                        float dimX = dimensions.x;\n                        float dimY = dimensions.y;\n                        float dimZ = dimensions.z;\n                        float posX = pos.x;\n                        float posY = mod( pos.z, dimY );\n                        float levels = floor( pos.z / dimY );\n                        float posZ = pos.y;\n\n                        // Paint windows\n                        if ( showWindows == 1 ) {\n                            // Normalise height\n                            float height = 1.0 - posY / dimY;\n                            if ( height > bottomWindow && height < topWindow ) {\n                                float p = 0.;\n                                if ( posX < ( floor( dimX / 2.0 ) - 1.0 ) && posX > -( floor( dimX / 2.0 ) - 1.0 )) {\n                                    float width = ( posX + dimX / 2.0 );\n                                    float m = mod( width, windowWidth );\n                                    p = abs( floor( width / windowWidth ) );\n                                    float offsetL = windowWidth * ( (1.0 - windowPercent ) / 2.0 );\n                                    float offsetR = windowWidth - offsetL;\n                                    if ( m > offsetL && m < offsetR )\n                                        colorise = true;\n                                }\n                                if ( posZ < ( floor( dimZ / 2.0 ) - 1.0 ) && posZ > -( floor( dimZ / 2.0 ) - 1.0 )) {\n                                    float width = ( posZ + dimZ / 2.0 );\n                                    float m = mod( width, windowWidth );\n                                    p = abs( floor( width / windowWidth ) );\n                                    float offsetL = windowWidth * ( (1.0 - windowPercent ) / 2.0 );\n                                    float offsetR = windowWidth - offsetL;\n                                    if ( m > offsetL && m < offsetR )\n                                        colorise = true;\n                                }\n                                if ( colorise ) {\n                                    col = vec4( mix( darkGrey, windowColor, pow( rand( vec2( p, levels ) ), vMixin ) ), opacity );\n                                }\n                            }\n                        }\n                        if ( showLines == 1 ) {\n                            // Rules for horizontal lines\n                            // IGNORE BOTTOM LINE FOR NOW:  || posY > dimY - lineWidth\n                            if ( posY == 0.0 && fillRooves == 1 )  {\n                                col = vec4( mix( windowColor, darkGrey, 0.5 ), opacity );\n                            }\n                            else if ( posY < lineWidth ) {\n                                // This gives just lines\n                                if ( posZ < - ( dimZ / 2.0 ) + lineWidth || posZ > ( dimZ / 2.0 ) - lineWidth )\n                                    col = vec4( lineColor, opacity );\n                                if ( posX < - ( dimX / 2.0 ) + lineWidth || posX > ( dimX / 2.0 ) - lineWidth )\n                                    col = vec4( lineColor, opacity );\n                            }\n                            else {\n                                // Rules for vertical lines\n                                if ( posZ < - ( dimZ / 2.0 ) + lineWidth )\n                                    if ( posX < - ( dimX / 2.0 ) + lineWidth || posX > ( dimX / 2.0 ) - lineWidth )\n                                        col = vec4( lineColor, opacity );\n                                if ( posZ > ( dimZ / 2.0 ) - lineWidth )\n                                    if ( posX < - ( dimX / 2.0 ) + lineWidth || posX > ( dimX / 2.0 ) - lineWidth )\n                                        col = vec4( lineColor, opacity );\n                            }\n                        }\n                        outgoingLight = vec3( col.r, col.g, col.b );\n                        diffuseColor = vec4( col.r, col.g, col.b, col.a );\n                    `;\n                    return shader;\n                },\n\n                terrainVertexShaderParams: function() {\n                    var shader = `\n                        uniform float size;\n                        uniform float maxHeight;\n                        attribute float height;\n                        attribute float trail;\n                        attribute float patch;\n                        varying float vHeight;\n                        varying float vTrail;\n                        varying float vPatch;\n                        `;\n                    return shader;\n                },\n                terrainVertexShaderMain: function() {\n                    var shader = `\n                            vHeight = height;\n                            vTrail = trail;\n                            vPatch = patch;\n                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position,1.0 );\n                        `;\n                    return shader;\n                },\n\n                terrainFragmentShaderParams: function() {\n                    var shader = `\n                            uniform float size;\n                            uniform float maxHeight;\n                            varying float vHeight;\n                            varying float vTrail;\n                            varying float vPatch;\n                            // Terrain colors\n                            uniform vec3 groundLevelColor;\n                            uniform vec3 lowland1Color;\n                            uniform vec3 lowland2Color;\n                            uniform vec3 midland1Color;\n                            uniform vec3 midland2Color;\n                            uniform vec3 highlandColor;\n                            uniform float stop1;\n                            uniform float stop2;\n                            uniform float stop3;\n                            uniform float stop4;\n                            uniform float stop5;\n                            // Mix shadows\n                            uniform float shadowMix;\n                        `;\n                    return shader;\n                },\n                terrainFragmentShaderMain: function() {\n                    var shader = `\n                        vec4 groundLevel = vec4( groundLevelColor, opacity );\n                        vec4 lowland1 = vec4( lowland1Color, opacity );\n                        vec4 lowland2 = vec4( lowland2Color, opacity );\n                        vec4 midland1 = vec4( midland1Color, opacity );\n                        vec4 midland2 = vec4( midland2Color, opacity );\n                        vec4 highland = vec4( highlandColor, opacity );\n                        float range;\n                        vec4 col;\n\n                        float alphaChannel = opacity;\n                        vec3 diffusion = diffuse;\n                        float elevation = vHeight / maxHeight;\n                        if ( vPatch > 0.0 ) {\n                            if ( elevation <=  0.0 ) {\n                                col = vec4( 0.0, 0.0, 0.0, 0.0 );\n                                alphaChannel = 0.0;\n                                diffusion = vec3( 0.0, 0.0, 0.0 );\n                            }\n                            else {\n                                col = vec4( vPatch, vPatch, vPatch, 1.0 );\n                            }\n                        }\n                        else if ( vTrail > 0.0 ) {\n                            col = vec4( vTrail, vTrail, vTrail, 1.0 );\n                        }\n                        else {\n                            if ( elevation == 0.0 ) {\n                                col = vec4( 0.0, 0.0, 0.0, 0.0 );\n                                alphaChannel = 0.0;\n                                diffusion = vec3( 0.0, 0.0, 0.0 );\n                            }\n                            else if ( elevation < stop1 ) {\n                                range = ( elevation - 0.0 ) * ( 1.0 / stop1 );\n                                col = mix( groundLevel, lowland1, range );\n                            }\n                            else if ( elevation < stop2 ) {\n                                range = ( elevation - stop1 ) * ( 1.0 / ( stop2 - stop1 ) );\n                                col = mix( lowland1, lowland2, range );\n                            }\n                            else if ( elevation < stop3 ) {\n                                range = ( elevation - stop2 ) * ( 1.0 / ( stop3 - stop2 ) );\n                                col = mix( lowland2, midland1, range );\n                            }\n                            else if ( elevation < stop4 ) {\n                                range = ( elevation - stop3 ) * ( 1.0 / ( stop4 - stop3 ) );\n                                col = mix( midland1, midland2, range );\n                            }\n                            else if ( elevation < stop5 ) {\n                                range = ( elevation - stop4 ) * ( 1.0 / ( stop5 - stop4 ) );\n                                col = mix( midland2, highland, range );\n                            }\n                            else  {\n                                col = highland;\n                            }\n                        }\n                        //outgoingLight = vec3( col.r, col.g, col.b );\n                        //diffuseColor = vec4( diffuse, alphaChannel );\n\n                        // Allow for a blending of shadows and gradient colors\n                        vec4 tmp = mix( vec4( outgoingLight, 0.0 ), col, shadowMix );\n                        outgoingLight = vec3( tmp.r, tmp.g, tmp.b );\n                        diffuseColor = vec4( diffusion, alphaChannel );\n                        `;\n\n                    return shader;\n                },\n\n                agentVertexShader: function() {\n                    var shader = `\n                        uniform float size;\n                        attribute float alpha;\n                        attribute vec3 color;\n                        varying float vAlpha;\n                        varying vec3 vColor;\n\n                        void main() {\n                            vAlpha = alpha;\n                            vColor = color; // set RGB color associated to vertex; use later in fragment shader.\n                            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n                            // option ( 1 ): draw particles at constant size on screen\n                            // gl_PointSize = size;\n                            // option ( 2 ): scale particles as objects in 3D space\n                            gl_PointSize = 1.0 * size * ( 300.0 / length( mvPosition.xyz ) );\n                            gl_Position = projectionMatrix * mvPosition;\n                        }\n                        `;\n                    return shader;\n                },\n                agentFragmentShader: function() {\n                    var shader = `\n                        varying vec3 vColor;\n                        uniform sampler2D texture;\n                        varying float vAlpha;\n\n                        void main() {\n                            gl_FragColor = vec4( vColor, vAlpha );\n                            // sets a white particle texture to desired color\n                            gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );\n                        }\n                        `;\n                    return shader;\n                },\n\n                // LAMBERT SHADER OVERRIDE FOR SHADOWS\n\n                /**\n                 * Returns an array of Lambert uniforms.\n                 * @param  {Array} otherUniforms\n                 * @return {Array} Merged array of uniforms\n                 */\n                lambertUniforms: function( otherUniforms ) {\n\n                    var uniforms = THREE.UniformsUtils.merge( [\n                            THREE.UniformsLib[ \"common\" ],\n                            THREE.UniformsLib[ \"fog\" ],\n                            THREE.UniformsLib[ \"lights\" ],\n                            THREE.UniformsLib[ \"shadowmap\" ],\n                            {\n                                \"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n                                \"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n                            }\n                        ] );\n                    return _.extend( uniforms, otherUniforms );\n\n                },\n\n                /**\n                 * Generates a vertex shader for a Lambert shader.\n                 */\n                lambertShaderVertex: function ( customParams, customCode ) {\n                    var vertexShader = [\n                        customParams,\n\n                        `\n                            #define LAMBERT\n\n                            varying vec3 vLightFront;\n\n                            #ifdef DOUBLE_SIDED\n\n                               varying vec3 vLightBack;\n\n                            #endif\n                        `,\n\n                        // Needed for three.js r71\n                        THREE.ShaderChunk[ \"common\" ],\n\n                        THREE.ShaderChunk[ \"map_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"color_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\n\n                        `void main() {`,\n\n                        customCode,\n\n\n                        THREE.ShaderChunk[ \"map_vertex\" ],\n                        THREE.ShaderChunk[ \"lightmap_vertex\" ],\n                        THREE.ShaderChunk[ \"color_vertex\" ],\n\n                        THREE.ShaderChunk[ \"morphnormal_vertex\" ],\n                        THREE.ShaderChunk[ \"skinbase_vertex\" ],\n                        THREE.ShaderChunk[ \"skinnormal_vertex\" ],\n                        THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n                        THREE.ShaderChunk[ \"morphtarget_vertex\" ],\n                        THREE.ShaderChunk[ \"skinning_vertex\" ],\n                        THREE.ShaderChunk[ \"default_vertex\" ],\n                        THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\n\n                        THREE.ShaderChunk[ \"worldpos_vertex\" ],\n                        THREE.ShaderChunk[ \"envmap_vertex\" ],\n                        THREE.ShaderChunk[ \"lights_lambert_vertex\" ],\n                        THREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n                        `}`\n\n                    ].join( \"\\n\" );\n\n                    return vertexShader;\n                },\n                lambertShaderFragment: function ( customParams, customCode ) {\n\n                    var fragmentShader = [\n\n                        customParams,\n\n                        `\n                        uniform vec3 diffuse;\n                        uniform vec3 emissive;\n                        uniform float opacity;\n\n                        varying vec3 vLightFront;\n\n                        #ifdef DOUBLE_SIDED\n\n                           varying vec3 vLightBack;\n\n                        #endif\n                        `,\n\n                        THREE.ShaderChunk[ \"common\" ],\n                        THREE.ShaderChunk[ \"color_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"map_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"fog_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\n\n                        `\n                        void main() {\n\n                           vec3 outgoingLight = vec3( 0.0 ); // outgoing light does not have an alpha, the surface does\n                           vec4 diffuseColor = vec4( diffuse, opacity );\n                        `,\n                        customCode, // must set gl_FragColor!\n\n                        THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\n                        THREE.ShaderChunk[ \"map_fragment\" ],\n                        THREE.ShaderChunk[ \"color_fragment\" ],\n                        THREE.ShaderChunk[ \"alphamap_fragment\" ],\n                        THREE.ShaderChunk[ \"alphatest_fragment\" ],\n                        THREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n                        `\n                        #ifdef DOUBLE_SIDED\n\n                           if ( gl_FrontFacing )\n                               outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n                           else\n                               outgoingLight += diffuseColor.rgb * vLightBack + emissive;\n\n                        #else\n\n                           outgoingLight += diffuseColor.rgb * vLightFront + emissive;\n\n                        #endif\n                        `,\n\n                        THREE.ShaderChunk[ \"lightmap_fragment\" ],\n                        THREE.ShaderChunk[ \"envmap_fragment\" ],\n                        THREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n                        THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n                        THREE.ShaderChunk[ \"fog_fragment\" ],\n\n                        `\n                            gl_FragColor = vec4( outgoingLight, diffuseColor.a ); // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\n                        }\n                        `\n\n                    ].join( \"\\n\" );\n\n                    return fragmentShader;\n\n                },\n\n\n                // PHONG SHADER OVERRIDE FOR SHADOWS\n\n                /**\n                 * Returns an array of Lambert uniforms.\n                 * @param  {Array} otherUniforms\n                 * @return {Array} Merged array of uniforms\n                 */\n                phongUniforms: function( otherUniforms ) {\n\n                    var uniforms = THREE.UniformsUtils.merge( [\n                        THREE.UniformsLib[ \"common\" ],\n                        THREE.UniformsLib[ \"aomap\" ],\n                        THREE.UniformsLib[ \"lightmap\" ],\n                        THREE.UniformsLib[ \"emissivemap\" ],\n                        THREE.UniformsLib[ \"bump\" ],\n                        THREE.UniformsLib[ \"normalmap\" ],\n                        THREE.UniformsLib[ \"fog\" ],\n                        THREE.UniformsLib[ \"lights\" ],\n                        THREE.UniformsLib[ \"shadowmap\" ],\n\n                        {\n                            \"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n                            \"specular\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n                            \"shininess\": { type: \"f\", value: 0 }\n                        }\n                    ] );\n                    return _.extend( uniforms, otherUniforms );\n\n                },\n\n                /**\n                 * Generates a vertex shader for a Lambert shader.\n                 */\n                phongShaderVertex: function ( customParams, customCode ) {\n                    var vertexShader = [\n                        customParams,\n\n                        \"#define PHONG\",\n\n                        \"varying vec3 vViewPosition;\",\n\n                        \"#ifndef FLAT_SHADED\",\n\n                        \"   varying vec3 vNormal;\",\n\n                        \"#endif\",\n\n                        THREE.ShaderChunk[ \"common\" ],\n                        THREE.ShaderChunk[ \"uv_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"color_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n                        THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\n\n\n                        `void main() {`,\n\n                        customCode,\n                        THREE.ShaderChunk[ \"uv_vertex\" ],\n                        THREE.ShaderChunk[ \"uv2_vertex\" ],\n                        THREE.ShaderChunk[ \"color_vertex\" ],\n\n                        THREE.ShaderChunk[ \"morphnormal_vertex\" ],\n                        THREE.ShaderChunk[ \"skinbase_vertex\" ],\n                        THREE.ShaderChunk[ \"skinnormal_vertex\" ],\n                        THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n                    \"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\n\n                    \"   vNormal = normalize( transformedNormal );\",\n\n                    \"#endif\",\n\n                        THREE.ShaderChunk[ \"morphtarget_vertex\" ],\n                        THREE.ShaderChunk[ \"skinning_vertex\" ],\n                        THREE.ShaderChunk[ \"default_vertex\" ],\n                        THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\n\n                    \"   vViewPosition = - mvPosition.xyz;\",\n\n                        THREE.ShaderChunk[ \"worldpos_vertex\" ],\n                        THREE.ShaderChunk[ \"envmap_vertex\" ],\n                        THREE.ShaderChunk[ \"lights_phong_vertex\" ],\n                        THREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n                    \"}\"\n\n                    ].join( \"\\n\" );\n\n                    return vertexShader;\n                },\n                phongShaderFragment: function ( customParams, customCode ) {\n\n                    var fragmentShader = [\n\n                        customParams,\n\n                        \"#define PHONG\",\n\n                        \"uniform vec3 diffuse;\",\n                        \"uniform vec3 emissive;\",\n                        \"uniform vec3 specular;\",\n                        \"uniform float shininess;\",\n                        \"uniform float opacity;\",\n\n                        THREE.ShaderChunk[ \"common\" ],\n                        THREE.ShaderChunk[ \"color_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"uv_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"map_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"emissivemap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"fog_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n                        THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\n\n                        `\n                        void main() {\n\n                        `,\n                        \"   vec3 outgoingLight = vec3( 0.0 );\",\n                        \"   vec4 diffuseColor = vec4( diffuse, opacity );\",\n                        \"   vec3 totalAmbientLight = ambientLightColor;\",\n                        \"   vec3 totalEmissiveLight = emissive;\",\n\n                        THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\n                        THREE.ShaderChunk[ \"map_fragment\" ],\n                        THREE.ShaderChunk[ \"color_fragment\" ],\n                        THREE.ShaderChunk[ \"specularmap_fragment\" ],\n                        THREE.ShaderChunk[ \"lightmap_fragment\" ],\n                        THREE.ShaderChunk[ \"aomap_fragment\" ],\n                        THREE.ShaderChunk[ \"emissivemap_fragment\" ],\n\n\n                        THREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\n                        THREE.ShaderChunk[ \"envmap_fragment\" ],\n                        THREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n                        THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n                        THREE.ShaderChunk[ \"fog_fragment\" ],\n\n                        customCode, // must set gl_FragColor!\n\n                        // Really want this as the last step\n                        THREE.ShaderChunk[ \"alphamap_fragment\" ],\n                        THREE.ShaderChunk[ \"alphatest_fragment\" ],\n\n                    \"   gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\n\n                    \"}\"\n\n                    ].join( \"\\n\" );\n\n                    return fragmentShader;\n\n                },\n\n                /**\n                 * Generates a list of shaders for debugging.\n                 * @return {string} all the shaders\n                 */\n                allShaders: function() {\n\n                    return [\n\n                        ShaderUtils.lambertShaderVertex(\n\n                            ShaderUtils.buildingVertexShaderParams(),\n                            ShaderUtils.buildingVertexShaderMain()\n\n                        ),\n                        ShaderUtils.lambertShaderFragment(\n\n                            ShaderUtils.buildingFragmentShaderParams(),\n                            ShaderUtils.buildingFragmentShaderMain()\n\n                        ),\n                        ShaderUtils.lambertShaderVertex(\n\n                            ShaderUtils.terrainVertexShaderParams(),\n                            ShaderUtils.terrainVertexShaderMain()\n\n                        ),\n                        ShaderUtils.lambertShaderFragment(\n\n                            ShaderUtils.terrainFragmentShaderParams(),\n                            ShaderUtils.terrainFragmentShaderMain()\n\n                        ),\n\n                        ShaderUtils.agentVertexShader(),\n                        ShaderUtils.agentFragmentShader(),\n\n                    ].join( \"\\n\" )\n\n                }\n            }\n\n        return FiercePlanet;\n\n    }\n)\n\n"],"sourceRoot":"/source/"}