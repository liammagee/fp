<html>
    <head>
        <title>Fierce Planet</title>
        <base href="../">
        <link rel="stylesheet" type="text/css" href="../css/fp.css">
        <script src="../js/require.js"></script>
        <script>
        requirejs.config({
            baseUrl: '../js',
            "shim": {
                "underscore": { exports: "_" },
                "dat.gui": { exports: "dat.gui" },
                "smoothie": { exports: "SmoothieChart" },
                "stats.min": { exports: "Stats" },
                "jstat.min": { exports: "jStat" },
                "three": { exports: "THREE" },
                "Mirror": ["three"],
                "WaterShader": ["three"],
                "TerrainLoader": { deps: ["three"], exports: "TerrainLoader" },
                "TrackballControls": {  deps: ["three"], exports: "TrackballControls" },
                "OrbitControls": {  deps: ["three"], exports: "OrbitControls" },
                "PointerLockControls": {  deps: ["three"], exports: "PointerLockControls" },
                "controls/MouseControls": {  deps: ["three"], exports: "MouseControls" },
                "controls/VRControls": {  deps: ["three"], exports: "VRControls" },
                "effects/VREffect": {  deps: ["three"], exports: "VREffect" },
            }
        })
        requirejs([
                "fp",
                "dat.gui",
                "smoothie",
                "stats.min",
                "jstat.min",
                "javascript.util",
                "jsts",
                "Mirror",
                "WaterShader",
                "TerrainLoader",
                "THREEx.KeyboardState",
                "TrackballControls",
                "PointerLockControls",
                "controls/MouseControls",
                "controls/VRControls",
                "effects/VREffect",
            ],
            function() {
                var config = {
                  "preset": "Default",
                  "remembered": {
                    "Default": {
                        // Agent options
                        "1": {
                            "initialPopulation": 20,
                            "initialExtent": 100,
                            // "maxExtent": 100,
                            // "initialX": 50,
                            // "initialY": 50,
                            // "randomAge": true,
                            "chanceToJoinNetwork": 0.05,
                            "chanceToJoinNetworkWithHome": 0.5,
                            "chanceToJoinNetworkWithBothHomes": 0.5,
                            "chanceToFindPathToHome": 0.01,
                            "chanceToFindPathToOtherAgentHome": 0.01,
                            // "initialCircle": true,
                            // "noWater": true,
                            // "noUphill": false,
                            // "useStickman": true,
                            // "visitHomeBuilding": 0.02,
                            // "visitOtherBuilding": 0.002,
                            "establishLinks": true,
                            "size": 400,
                            "terrainOffset": 0,
                            // "size": 40,
                            // "terrainOffset": 20,
                            "useStickman": true,
                            "shuffle": true,
                            "initialSpeed": 1,
                            "initialPerturbBy": 0,
                            "movementRelativeToPatch": 100,
                            "movementInPatch": 100,
                            "movementStrictlyIntercardinal": true,
                         },
                        // Building options
                        "2": {
                            "roads": 0.0,
                            "water": 0.0,
                            "otherBuildings": 0.25,
                            "distanceFromOtherBuildingsMin": 5000,
                            "distanceFromOtherBuildingsMax": 5500,
                            "buildingHeight": 0.0,
                            "detectBuildingCollisions": true,

                            "create": false,

                            // "maxNumber": 250,

                            // // Carry over from generation
                            // "heightA": 2,
                            // "heightB": 10,

                            // // Influences

                            // // Building form
                            // "buildingForm": "rectangle",
                            // "spread": 10,
                            // "randomForm": false,
                            // "rotateRandomly": false,
                            // "rotateSetAngle": 0,

                            // "destroyOnComplete": false,
                            // "loopCreateDestroy": false,

                            // // Visualisation
                            // "turning": false,
                            // "falling": false,
                            "riseRate": 1,

                            // // Dimensions
                            "minHeight": 10,
                            "maxHeight": 70,
                            // "minWidth": 40,
                            // "maxWidth": 200,
                            // "minLength": 40,
                            // "maxLength": 200,
                            // "maxLevels": 0,
                            // "maxLevels": 0,
                            // "width": 0,
                            // "length": 0,
                            // "levelHeight": 40,

                            // // View parameters
                            // "useShader": true,
                            // "useLevelOfDetail": true,
                            // "highResDistance": 1000,
                            // "lowResDistance": 7500,
                            // "opacity": 1.0,

                            // // Fill parameters
                            // "showFill": true,
                            // "fillRooves": false,

                            // // Stroke parameters
                            // "showLines": true,
                            // "linewidth": 1.0,

                            // // Window parameters
                            // "showWindows": true,
                            // "windowsRandomise": false,
                            // "windowWidth": 15,
                            // "windowPercent": 60,
                            // "windowsStartY": 40,
                            // "windowsEndY": 80,
                            // "windowsLine": true,
                            // "windowsFill": false,

                            // // Stagger
                            // "stagger": true,
                            // "staggerAmount": 40,

                            // // Taper
                            // "taper": true,
                            // "taperExponent": 2,
                            // "taperDistribution": 1,

                            // // Collision detection
                            // "detectBuildingCollisions": true,
                            // "detectRoadCollisions": true

                        },
                        // Road options
                        "3": {
                            "create": false

                            // "maxNumber": 200,  // Maximum number of roads - for performance reasons
                            // "roadWidth": 20,
                            // "roadDeviation": 20,
                            // "roadRadiusSegments": 10,
                            // "roadSegments": 10,
                            // "initialRadius": 100,
                            // "probability": 1,
                            // "lenMinimum": 100,
                            // "lenMaximum": 2000,
                            // "lenDistributionFactor": 3,
                            // "overlapThreshold": 3,
                            // "flattenAdjustment": 0.025,
                            // "flattenLift": 20
                        },
                        // Display options
                        "4": {
                            // "agentsShow": true,
                            "buildingsShow": true,
                            // "roadsShow": true,
                            "waterShow": true,
                            "networkShow": false,
                            "networkCurve": false,
                            // "networkCurvePoints": 20,
                            "patchesShow": false,
                            "patchesUpdate": true,
                            // "trailsShow": false,
                            // "trailsShowAsLines": false,
                            // "trailLength": 10000,
                            // "cursorShow": false,
                            // "cursorShowCell": true,
                            // "statsShow": true,
                            // "hudShow": true,
                            // "wireframeShow": false,
                             "dayShow": false,
//                             "skyboxShow": false,
                            // "chartShow": true,
                            // "guiShow": true,
                            // "guiShowControls": true,
                            // "guiShowAgentFolder": true,
                            // "guiShowBuildingsFolder": true,
                            // "guiShowRoadsFolder": true,
                            // "guiShowTerrainFolder": true,
                            // "guiShowDisplayFolder": true,
                            // "guiShowColorFolder": true,
                            // "pathsShow": true,
                            "terrainShow": true,
                            // "coloriseAgentsByHealth": false,
                            // "firstPersonView": false,
                            "cameraOverride": true,
                            "cameraX": 0,
                            "cameraY": 10000,
                            "cameraZ": 9000,
                            // "maximiseView": true,
                        },
                        // Color options
                        "5": {
                            // "colorDayBackground": 0x000000,
                            // "colorDayRoad": 0x474747,
                            // "colorDayAgent": 0x4747b3,
                            // "colorDayNetwork": 0x474747,
                            // "colorDayTrail": 0x474747,
                            // "colorDayPath": 0x474747,
                            // "colorDayBuildingFill": 0xb1abab,
                            // "colorDayBuildingLine": 0x222222,
                            // "colorDayBuildingWindow": 0x222222,

                            "colorNightBackground": 0x033303,
                            "colorNightRoad": 32 * 256 * 256 + 32 * 256 + 32,
                            "colorNightAgent": 0xffffff,
                            "colorNightNetwork": 0xC8E857,
                            // "colorNightTrail": 0x47b347,
                            "colorNightPath": 0xffffff,
                            "colorNightBuildingFill": 0xd3d3d3,
                            // "colorNightBuildingLine": 0x838383,
                            "colorNightBuildingWindow": 0xffffff,

                            // "colorGraphPopulation": 0x4747b3,
                            // "colorGraphHealth": 0xb34747,
                            // "colorGraphPatchValues": 0x47b347,
                            "colorLightHemisphereSky": 0xffffff,
                            "colorLightHemisphereGround": 0xffffff,
                            "colorLightHemisphereIntensity": 0.9,
                            "colorLightDirectional": 0x88ff88,
                            "colorLightDirectionalIntensity": 0.1,

                            "colorDayTerrainGroundLevel": 0x000000,
                            "colorDayTerrainLowland1": 0x054801,
                            "colorDayTerrainLowland2": 0x548E0D,
                            "colorDayTerrainMidland1": 0xC8E857,
                            "colorDayTerrainMidland2": 0xCE983A,
                            "colorDayTerrainHighland": 0xFDFDFC,

                            // "colorNightTerrainGroundLevel": 0x000000, //0x054801,
                            // "colorNightTerrainLowland1": 0x054801, //0x548E0D,
                            // "colorNightTerrainLowland2": 0x548E0D, //0xC8E857,
                            // "colorNightTerrainMidland1": 0xC8E857, //0xF4C54C,
                            // "colorNightTerrainMidland2": 0xCE983A,
                            // "colorNightTerrainHighland": 0xFDFDFC,

                            "colorNightTerrainGroundLevel": 0x000000,
                            "colorNightTerrainLowland1": 0x274E1A,
                            "colorNightTerrainLowland2": 0x3F7E2A,
                            "colorNightTerrainMidland1": 0x69B84F,
                            "colorNightTerrainMidland2": 0xA2D392,
                            "colorNightTerrainHighland": 0xFDFDFC,

                            "colorTerrainStop1": 0.5,
                            "colorTerrainStop2": 0.7,
                            "colorTerrainStop3": 0.8,
                            "colorTerrainStop4": 0.9,
                            "colorTerrainStop5": 1.0,

                            "colorTerrainOpacity": 0.99,
                        },
                        // Terrain options
                        "6": {
                            // "renderAsSphere": true,
                            "loadHeights": false ,
                            "gridExtent": 8000,
                            "gridPoints": 195,
                            "maxTerrainHeight": 2400,
                            "shaderUse": true,
                            "multiplier": 1,
                            // "mapIndex": 0,
                            "patchSize": 4 // Should be: N * patchSize = gridPoints - 1

                         },
                    }
                  }
                };
                var GeoLanguageAgent = function() {
                    fp.Agent.call( this );
                    this.lexicon = 0.0;
                    this.origState = null;
                    this.spokenState = 0;
                    this.age = 20 + Math.floor( Math.random() * 20 );
                    this.sex = Math.floor( Math.random() * 2 );
                    this.ticksSinceReproduction = 0;
                    this.motherNode = null;
                    this.wordList = _.range( 10 ).map( function () { return 0.0 } );


                    /**
                     * Overrides the Agent implementation.
                     */
                    this.generateDirectionVectorsAndWeights = function( seed ) {
                        var xl = this.lastPosition.x,
                                yl = this.lastPosition.y,
                                zl = this.lastPosition.z,
                                xd = this.direction.x,
                                yd = this.direction.y,
                                zd = this.direction.z,
                                isAlreadyOnRoad = fp.roadNetwork.indexValues.indexOf( fp.getIndex( xl, zl ) ) > -1;

                        // Logic for handling pre-determined paths
                        if ( _.isUndefined( this.pathComputed ) || this.pathComputed.length < 2 ) {
                            if ( Math.random() < fp.appConfig.agentOptions.chanceToFindPathToHome )  {
                                this.pathComputed = fp.pathNetwork.findPathHome( this );
                                this.pathPosition = 0;
                            }
                            else if ( Math.random() < fp.appConfig.agentOptions.chanceToFindPathToOtherAgentHome ) {
                                this.pathComputed = fp.pathNetwork.findPathToOtherAgentsHome( this );
                                this.pathPosition = 0;
                            }
                        }

                        // Work out if we have a precomputed path
                        var dir = this.nextComputedDirection();
                        if ( !_.isUndefined( dir ) )
                            return [ [ dir, 1.0 ] ];

                        var directionCount = 8,
                                directions = new Array( directionCount  );

                        // Weight variables
                        var weight = 1.0, weightForRoadIsSet = false;

                        // Pre-calculate speed and current angle
                        var patchSize = fp.appConfig.terrainOptions.patchSize *
                                fp.appConfig.terrainOptions.multiplier *
                                ( fp.appConfig.agentOptions.movementInPatch / 100 );
                        var angle = Math.atan2( zd, xd ),
                                hyp = Math.sqrt( xd * xd + zd * zd ),
                                divisor = directionCount / 2;

                        // First obtain heights from the surrounding points
                        var newDirections = [];
                        for ( var i = 0; i < directionCount; i++ ) {
                            // Slight rounding errors using above calculation
                            var newAngle = angle + ( i * Math.PI / divisor );
                            xd = Math.cos( newAngle ) * hyp;
                            yd = 0;
                            zd = Math.sin( newAngle ) * hyp;

                            // Calculate new position
                            var xn = xl + xd, yn = yl + yd, zn = zl + zd;

                            yn = fp.getHeight( xn, zn );
                            yn += fp.appConfig.agentOptions.terrainOffset;
                            yn += fp.appConfig.agentOptions.size / 2;

                            yd = ( yn - yl ) / fp.terrain.ratioExtentToPoint;
                            newDirections.push( new THREE.Vector3( xd, yd, zd ) );

                            // Set the direction
                            directions[ i ] = [ new THREE.Vector3( xd, yd, zd ), 0 ];
                        }

                        newDirections = _.chain( newDirections ).
                                shuffle(). // To disorder duplicate values before sort
                                sortBy( function( vec ) { return Math.abs( vec.y ); } ).
                                reverse().
                                value();

                        for ( var i = 0; i < newDirections.length; i++ ) {
                            var direction = newDirections[ i ];
                            var weight = Math.pow( seed, 0.125 );
                            // For proper randomness, set all weights tot he same value
                            switch( i ) {
                                case 0:
                                    weight = 0.3;
                                    break;
                                case 1:
                                    weight = 0.2;
                                    break;
                                case 2:
                                    weight = 0.15;
                                    break;
                                case 3:
                                    weight = 0.1;
                                    break;
                                case 4:
                                    weight = 0.1;
                                    break;
                                case 5:
                                    weight = 0.05;
                                    break;
                                case 6:
                                    weight = 0.05;
                                    break;
                                case 7:
                                    weight = 0.05;
                                    0.1;
                                    break;
                            }

                            directions[ i ] = [ direction, weight ];
                        }

                        directions = _.chain( directions ).
                                compact().
                                shuffle().
                                sort( function( a, b ) { return ( a[ 1 ] > b[ 1 ] ) ? 1 : ( a[ 1 ] < b [ 1 ]? -1 : 0 ); } ).
                                value();

                        return directions;
                    };


                    this.die = function() {
                        fp.scene.remove( fp.agentNetwork.particles );
                        var index = fp.agentNetwork.agents.indexOf(this);
                        fp.agentNetwork.agents.splice(index, 1);
                        fp.agentNetwork.updateAgentParticleSystem();
                        fp.scene.add( fp.agentNetwork.particles );
                    };
                };
                GeoLanguageAgent.prototype = Object.create( fp.Agent.prototype );

                // Override PatchNetwork methods
                fp.PatchNetwork.prototype.elev;
                fp.PatchNetwork.prototype.attractiveness;
                /*
                fp.PatchNetwork.prototype.reviseValues = function() {
                    fp.patchNetwork.patchMeanValue = 0;
                    for (var i = 0; i < fp.patchNetwork.patchValues.length; i++) {
                        var patch = fp.patchNetwork.patchValues[i];
                        // if ( _.isUndefined( fp.patchNetwork.patches[i] ) && patch.value < patch.initialValue ) { // Recover
                        if ( patch.value < patch.initialValue ) { // Recover
                            patch.updatePatchValue( fp.appConfig.malthusOptions.patchRecoveryRate );
                        }
                        fp.patchNetwork.patchMeanValue += patch.value;
                    }
                    fp.patchNetwork.patchMeanValue /= fp.patchNetwork.patchValues.length;
                };
                */


                var vrEffect;
                var vrControls;
                var mouseControls;
                var headControls;

                var mouse = new THREE.Vector2(), INTERSECTED;


                var sim =  {
                    counter: 0,
                    positions: [],


                    updateAgentColor: function( agent ) {
                        var lexicon = agent.lexicon;
                        var redComponent = Math.floor( 256 * (agent.lexicon) + 64 );
                        redComponent = (redComponent > 255) ? 255 : redComponent;
                        var blueComponent = Math.floor( 256 * agent.lexicon );
                        var greenComponent = Math.floor( 256 * agent.lexicon );
                        agent.color = 'rgb(' + redComponent + ', ' + greenComponent + ', ' + blueComponent + ')';
                        // agent.color = 'rgb(' + Math.floor(256 * (1.0 - agent.lexicon)) + ', 0, ' + Math.floor(256 * agent.lexicon) + ')';
                    },

                    distributeGrammars: function() {
                        var sim = this;
                        fp.agentNetwork.agents.forEach(function(agent) {
                            var chance = Math.random();
                            if ( chance > fp.appConfig.geoGamesOptions.percentageLanguage1 )
                                agent.lexicon = 0.0;
                            else
                                agent.lexicon = 1.0;
                            agent.originalState = agent.lexicon;
                            agent.spokenState = agent.lexicon;
                            agent.wordList = _.range(10).map(function () { return agent.originalState });
                            sim.updateAgentColor( agent );
                        });

                        // the next bit deals with making one node William Marsters so he can not change his lexicon and be historically accurate with age at death
                        var agentsWithOne = _.select(fp.agentNetwork.agents, function( a ) { return a.lexicon == 1.0 } );
                        var index = Math.floor( Math.random() * agentsWithOne.length );
                        // For debugging: fp.sim.marsters
                        this.marsters = agentsWithOne[ index ];
                        agentsWithOne[ index ].age = 40;

                        fp.agentNetwork.updateAgentShader();

                        // Shorthand to count agent lexicons
                        //_.reduce(_.map(fp.agentNetwork.agents, function(a){return a.lexicon}), function(memo, num) {return num + memo;}, 0);
                    },

                    redistribute: function() {
                        LanguageChange.distributeGrammars();
                    },

                    chooseLanguage: function( agent, index ) {
                        var modifier = agent.wordList[ index ];
                        if ( modifier < Math.random() )
                            agent.spokenState = 0;
                        else
                            agent.spokenState = 1;
                    },

                    // ;;this is where the "self" agent updates its wordlist on the basis of the interaction. ;;CHECK DO I HAVE TO USE "OF MYSELF" HERE TO REF SELF?
                    updateSelf: function( agent, result, wordIndex ) {
                        var rate = fp.appConfig.geoGamesOptions.rate;
                        if ( result == 0 ) { //;; i.e. situation where agent used 0 and succeeded
                            var newValue = agent.wordList[ wordIndex ] - rate; //;; so they are encouraged in their use of 0 for that item by decreasing likelihood of using 1 by whatever the rate has been set to in the slider.
                            newValue = newValue < 0 ? 0 : newValue;
                            agent.wordList[ wordIndex ] = newValue;
                        }
                        else if ( result == 1 ) { //;; ie. situation where agent (self) used 1 and failed
                            var newValue = agent.wordList[ wordIndex ] - rate;
                            newValue = newValue < 0 ? 0 : newValue;
                            agent.wordList[ wordIndex ] = newValue;
                        }
                        else if ( result == 2 ) { //;; so they are encouraged and increase chance of using 1 again
                            var newValue = agent.wordList[ wordIndex ] + rate;
                            newValue = newValue > 1 ? 1 : newValue;
                            agent.wordList[ wordIndex ] = newValue;
                        }
                        else if ( result == 3 ) { //;; i.e. situation where agent used 0 and failed.
                            var newValue = agent.wordList[ wordIndex ] + rate;
                            newValue = newValue > 1 ? 1 : newValue;
                            agent.wordList[ wordIndex ] = newValue;
                        }
                        if ( agent.marsters == true && fp.appConfig.geoGamesOptions.marstersDoesntChange == true ) {
                            agent.lexicon = 1;
                            agent.wordList = _.range( 10 ).map( function () { return 1.0 } );
                        }
                    },

                    interact: function() {
                        var sim = this;
                        var rate = fp.appConfig.geoGamesOptions.rate;
                        for ( var i = 0; i < fp.agentNetwork.agents.length; i++ ) {
                            var agent = fp.agentNetwork.agents[ i ];

                            var agents = fp.patchNetwork.patches[ fp.getPatchIndex( agent.position.x, agent.position.z ) ];
                            if ( _.isUndefined( agents ) )
                                continue;
                            if ( agents.length <= 1 )
                                continue;
                            var wordIndex = Math.floor( Math.random() * 10 );
                            var result = 5;
                            // Pick a partner at random
                            var otherAgent = agents[ Math.floor( Math.random() * agents.length ) ]
                            if ( otherAgent == agent )
                                continue;
                            var otherWordIndex = Math.floor( Math.random() * 10 );
                            this.chooseLanguage( otherAgent, otherWordIndex );
                            if ( otherAgent.spokenState == 0 ) { // i.e. if partner uses language 0
                                if ( agent.spokenState == 0 ) { // and self-agent also choose language 0 then success
                                    // so they are encouraged in their use of 0 for that item by decreasing likelihood of using 1 by whatever the rate has been set to in the slider.
                                    var newValue = otherAgent.wordList[ otherWordIndex ] - rate;
                                    newValue = newValue < 0 ? 0 : newValue;
                                    otherAgent.wordList[ otherWordIndex ] = newValue;
                                    result = 0;
                                }
                                else {
                                    var newValue = otherAgent.wordList[ otherWordIndex ] + rate;
                                    newValue = newValue > 1 ? 1 : newValue;
                                    otherAgent.wordList[ otherWordIndex ] = newValue;
                                    result = 1;
                                }
                            }
                            else {
                                if ( agent.spokenState == 1 ) {
                                    var newValue = otherAgent.wordList[ otherWordIndex ] + rate;
                                    newValue = newValue > 1 ? 1 : newValue;
                                    otherAgent.wordList[ otherWordIndex ] = newValue;
                                    result = 2;
                                }
                                else {
                                    var newValue = otherAgent.wordList[ otherWordIndex ] - rate;
                                    newValue = newValue < 0 ? 0 : newValue;
                                    otherAgent.wordList[ otherWordIndex ] = newValue;
                                    result = 3;
                                }
                            }
                            otherAgent.lexicon = jStat.mean( otherAgent.wordList );
                            this.updateSelf( agent, result, wordIndex );
                            agent.lexicon = jStat.mean( agent.wordList );
                            if ( otherAgent.marsters == true && fp.appConfig.geoGamesOptions.marstersDoesntChange == true ) {
                                otherAgent.lexicon = 1;
                                otherAgent.wordList = _.range( 10 ).map( function () { return 1.0 } );
                            }
                        }
                    },

                    updateTicks: function() {
                        var rate = fp.appConfig.geoGamesOptions.rate;
                        for ( var i = 0; i < fp.agentNetwork.agents.length; i++ ) {
                            var agent = fp.agentNetwork.agents[ i ];
                            agent.ticksSinceReproduction++;
                        }
                    },


                    haveBaby: function( agent ) {
                        // i.e. if a year or more has passed since her previous baby was born
                        if ( agent.ticksSinceReproduction > fp.appConfig.geoGamesOptions.ticksPerYear ) {

                            var eligibleHusbands = _.select( fp.agentNetwork.agents, function( male ) {
                                return ( male.sex == 0 && male.age > 18 && male.motherNode != agent.motherNode );
                            } );
                            var husband = _.chain( eligibleHusbands ).shuffle().first().value();

                            // ;; this needs to equal approximately 30% chance over a year, but it's going to depend on ticks-per-year rate.
                            if ( Math.random() * 100 <= ( 300 * fp.timescale.ticksPerYear ) ) {
                                var child = fp.agentNetwork.createAgent();
                                child.sex = Math.floor( Math.random() * 2 );
                                child.size = 2;
                                child.age = 0;
                                child.ticksSinceReproduction = 0;
                                child.motherNode = agent;
                                child.setPosition( agent.position );
                                fp.agentNetwork.agents.push( child );

                                if ( fp.appConfig.agentOptions.childrensLanguage == "bilingual" ) {
                                    child.lexicon = ( agent.lexicon + husband.lexicon ) / 2;
                                    child.wordList = _.range( 10 ).map( function () { return 0.0 } );
                                    for ( var i = 0; i < 10; i++ ) {
                                        child.wordList[ i ] = ( agent.wordList[ i ] + husband.wordList[ i ] ) / 2;
                                    }
                                }
                                else if ( fp.appConfig.agentOptions.childrensLanguage == "paternal" ) {
                                    child.lexicon = husband.lexicon;
                                    child.wordList = husband.wordList;
                                }

                                agent.ticksSinceReproduction = 0;
                            }
                        }
                    },

                    reproduce: function() {
                        var reproducibles = _.select( fp.agentNetwork.agents, function( agent ) {
                            return ( agent.size == 2 && agent.sex == 1 && agent.age > 18 && agent < 40 );
                        } );
                        for ( var i = 0; i < reproducibles.length; i++ ) {
                            var agent = reproducibles[ i ];
                            this.haveBaby( agent );
                        }
                        //;; import extra woman
                        var importedWoman = fp.agentNetwork.createAgent();
                        importedWoman.size = 1;
                        importedWoman.sex = 1;
                        importedWoman.age = 18 + Math.floor( Math.random() * 20 );
                        importedWoman.ticksSinceReproduction = 0;
                        importedWoman.motherNode = importedWoman;
                        importedWoman.lexicon = 0.0;
                        importedWoman.wordList = _.range( 10 ).map( function () { return 0.0 } );
                        importedWoman.origState = 0;
                        fp.agentNetwork.agents.push( importedWoman );
                        this.haveBaby( importedWoman );
                    },

                    checkBirthDeath: function() {
                        if ( fp.timescale.frameCounter % fp.appConfig.geoGamesOptions.ticksPerYear == 0 ) {
                            var rate = fp.appConfig.geoGamesOptions.rate;
                            for ( var i = 0; i < fp.agentNetwork.agents.length; i++ ) {
                                var agent = fp.agentNetwork.agents[ i ];
                                agent.age++;
                                if ( agent.marsters && fp.appConfig.geoGamesOptions.historicallyAccurate ) {
                                    if ( agent.age == 82 )
                                        agent.die();
                                }
                                else {
                                    // ;; equation mattias wrote to approximate a shifted bell curve where at age 100 you have 1, and two std devs bring you to 60 years old.
                                    var prob = Math.pow( Math.E, ( -Math.pow( ( agent.age - 100 ), 2 ) ) / ( 2 * Math.pow( 20, 2 ) ) );
                                    if ( Math.random() < prob )
                                        agent.die();
                                }
                                if ( agent.age > 14 && agent.age < 30 ) {
                                    if ( Math.random() < fp.appConfig.geoGamesOptions.leavingRate )
                                        agent.die();
                                }

                            }
                            this.reproduce();
                        }
                    },


                    setup: function() {
                        fp.timescale.framesToYear = 1;

                        this.marsters = null;
                        this.elevation = null;
                        this.slope = null;
                        this.aspect = null;

                        this.distributeGrammars();
                    },
                    tick: function() {
                        if ( fp.timescale.frameCounter % fp.appConfig.geoGamesOptions.ticksPerYear == 0 )
                            console.log( "Years: " + fp.timescale.frameCounter / 100  );
                        var sim = this;
                         this.interact();
                         fp.agentNetwork.agents.forEach( function( agent ) {
                             sim.updateAgentColor( agent );
                         });
                         this.updateTicks();
                         if ( fp.appConfig.geoGamesOptions.reproduction == true ) {
                             this.checkBirthDeath();
                         }

                        headControls.update();
                        vrEffect.render( fp.scene, fp.camera );

                    }
                }


                function onWindowResize() {

                    fp.camera.aspect = window.innerWidth / window.innerHeight;
                    fp.camera.updateProjectionMatrix();

                    vrEffect.setSize( window.innerWidth, window.innerHeight );

                }

                fp.init( config, sim, function() {
                    // Set up custom parameters
                    fp.appConfig.geoGamesOptions = {};
                    fp.appConfig.geoGamesOptions.percentageLanguage1 = 0.4;
                    fp.appConfig.geoGamesOptions.rate = 0.3;
                    fp.appConfig.geoGamesOptions.childrensLanguage = 1;
                    fp.appConfig.geoGamesOptions.historicallyAccurate = true;
                    fp.appConfig.geoGamesOptions.marstersDoesntChange = false;
                    fp.appConfig.geoGamesOptions.reproduction = true;
                    fp.appConfig.geoGamesOptions.languageSplitByGender = true;
                    fp.appConfig.geoGamesOptions.leavingRate = 0.15;
                    fp.appConfig.geoGamesOptions.ticksPerYear = 100;
                    var geoLangGamesFolder = fp.gui.addFolder( "GeoLang Games Options" );
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "percentageLanguage1", 0, 1).step( 0.01 );
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "rate", 0, 1).step( 0.01 );
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "childrensLanguage", 1, 3).step( 1 );
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "historicallyAccurate");
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "marstersDoesntChange");
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "reproduction");
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "languageSplitByGender");
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "leavingRate", 0, 0.3).step( 0.01 );
                    geoLangGamesFolder.add( fp.appConfig.geoGamesOptions, "ticksPerYear", 1, 1000).step( 1 );

                    // Set up VR
                    vrControls = new THREE.VRControls( fp.camera );
                    mouseControls = new THREE.MouseControls( fp.camera );
                    headControls = vrControls;

                    vrEffect = new THREE.VREffect( fp.renderer, VREffectLoaded );
                    function VREffectLoaded(error) {
                        if (error) {
                            console.log( error );
                            // fullScreenButton.innerHTML = error;
                            // fullScreenButton.classList.add('error');
                        }
                    }
                    window.addEventListener( 'resize', onWindowResize, false );


                    // Add custom class
                    fp.agentNetwork.agentClass = GeoLanguageAgent;
                    fp.patchNetwork.initialisePatchFunction = function() { return Math.random(); };
                    // fp.patchNetwork.initialisePatchFunction = function() { return 0.5; };


                    // Hack around using TerrainLoader, which assumes binary data type
                    var wholeFile;
                    fp.scene.remove( fp.terrain.plane );
                    fp.terrain = new fp.Terrain();
                    $.get("../assets/local-elevation.asc", function( data) {
                        wholeFile = data;
                        var lines = wholeFile.split( '\n' );
                        var cols = lines[ 0 ].split( ' ' )[ 1 ];
                        var rows = lines[ 1 ].split( ' ' )[ 1 ];
                        var len = lines.length;
                        var heights = lines.slice(6, lines.length - 1).join( ' ' ).split( ' ' );
                        // Get data into a scale initTerrain expects
                            heights = _.chain( heights).map( function( h ) { var v = parseFloat( h ); return isNaN( v ) ? null : v; } ).compact().value();

                        var max = _.max( heights );
                        var min = _.min( heights );
                        heights = _.map( heights, function( h ) { return 65535 * ( ( h - min ) / ( max - min ) ); } );
                        fp.appConfig.terrainOptions.loadHeights  = true;
                        fp.terrain.initTerrain( heights );
                        fp.animate(); // Kick off the animation loop

                        // Update chart - keep population
                        var series = fp.chart.seriesSet;
                        fp.chart.removeTimeSeries( series[ 2 ].timeSeries );
                        fp.chart.removeTimeSeries( series[ 1 ].timeSeries );
                        for ( var i = series.length - 1; i >= 0 ; i-- ) {
                            var timeSeries = series[ i ].timeSeries;
                            fp.chart.removeTimeSeries( timeSeries );
                        }
                        var colorPop = "#ff0000", colorLexicon= "#0000ff";
                        var popSeries = new TimeSeries( { strokeStyle: colorPop } );
                        var lexiconSeries = new TimeSeries( { strokeStyle: colorLexicon } );
                        var initPop = fp.appConfig.agentOptions.initialPopulation;

                        setInterval( function() {
                            if ( fp.AppState.runSimulation ) {
                                var popProportion = fp.agentNetwork.agents.length / ( initPop * 2 );
                                var lexiconMean = jStat.mean( _.map( fp.agentNetwork.agents, function( agent ) { return agent.lexicon; } ) );
                                popSeries.append( new Date().getTime(), popProportion );
                                lexiconSeries.append( new Date().getTime(), lexiconMean );
                            }
                        }, 500 );
                        fp.chart.addTimeSeries( popSeries, { strokeStyle: colorPop, fillStyle: "rgba( 255, 0, 0, 0.2 )", lineWidth: 4 } );
                        fp.chart.addTimeSeries( lexiconSeries, { strokeStyle: colorLexicon, fillStyle: "rgba( 0, 0, 255, 0.2 )", lineWidth: 4 } );
                        // Force new min / max values
                        fp.chart.options = _.extend( { minValue: 0.0, maxValue: 1.0 }, SmoothieChart.defaultChartOptions );
                        fp.chart.updateValueRange();

                        fp.appConfig.Setup();
                        fp.appConfig.Run();
                    } )
                } );
            }
        );

        </script>
    </head>
    <body>
        <div id="container"></div>
        <div id="links"></div>
    </body>
</html>
